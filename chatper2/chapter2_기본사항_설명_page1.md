데이터 동기화 서비스구현

분기의 수가 일반적으로 프로젝트를 진행하는 동안 빠르게 증가하며 분기의 실행여부를 결정하는 조건의 수가 증가한다.

- 멀티 디바이스 도익화 전략 설계
- 유용한 자바스크립트와 타입스크립트 기술, 맵객체와 문자열 리터럴 타입을 포함한 관련정보
- 프로젝트에서 전력패턴이 필요한 경우


---
### 동기화 전략이란
구현시 불필요하게 산만해지지 않도록 클라이언트는 HTTP요청이나 소켓대신 함수호출을 통해 서버와 직접 통신하도록 한다.
또한 인메모리 스토리지 즉 변수를 사용해 클라이언트와 서버측에 데이터를 저장하겠다.

제한된 네트워크 리소스를 전제로 두고

클라이언트가 동기화된것을 수정하지 않는다면.. (정적인 페이지) 데이터의 사본을 동기화된 상태로 유지할 수 있도록 일련의 API를 제공해야한다.
최종 수정된 타임스탬프를 비교하면 된다.
만일 클라이언트의 타임스탬프가 서버의 타임스탬프보다 더 오래됐다면, 새 타임스탬프와 함께 데이터 사본을 업데이트 하면 된다.

---
### 동기화할 데이터의 초기 구조 정의
클라이언트와 서버로부터 타임스탬프를 비교해야하므로 데이터구조에 timestamp 프로퍼티가 있어야한다. 
여기서는 데이터를 문자열로 동기화하려하므로, timestamp프로퍼티가 있는 DataStore 인터페이스를 server.ts에 추가한다.

---
### 타임스탬프를 비교하여 데이터 가져오기

현재 동기화 전략은 서버에서 클라이언트로의 단방향이다. 따라서 간단히 타임스탬프만 비교하면 된다.
만일 서버의 타임스템프가 더 최신이라면, 서버는 데이터와 서버측 타임스탬프로 응답한다. 그렇지 않다면 undefined로 응답한다.

constructor 파라미터 앞에 public, private, protected와 같은 접근 한정자(access modifier)를 붙이면 동일한 이름과 해당하는 접근권한을 갖는 프로퍼티가 생성된다. 
그리고 생성자(constructor)가 호출될때 값을 자동으로 할당한다.
---
### 양방향 동기화
클라이언트가 더 최신의 데이터를 갖고 있을 때 변경사항을 서버로 전달하는 방법
update 

---
### 몇가지 의미론적 문제
- 서버에서 클라이언트로의 데이터 저장소 전달은 적합하지 않다.
- Server에서는 synchronize 메서드의 반환타입으로 DataStore를 사용했다. 하지만 실제 전달한 것은 데이터 저장소가 아니라 데이터의 타임스템프가 포함된 정보이다. 우연히 동일한 프로퍼티를 가지게 된 것.
- 따라서 이들 각각을 두개의 인터페이스로 만들어야한다.

---

## 기능 추가
여러 항목 동기화
- 데이터 타입을 배열로 대체
- 서버 중심의 동기화 : 데이터 저장소에 많은 양의 데이터가 포함돼 있다면 이상적인 접근 방식은 최신이 아닌 항목만 업데이트 하는 것이다. 그러나 네트워크 사양등을 같이 고려해야한다.
- (사용자 데이터 동기화와 소프트웨어 확장기능 업데이트 확인간의 차이는?)
- 변경되는 데이터의 타임스탬프가 아니라 서버와 동기화되는 데이터의 타임스탬프를 저장한다면 어떻게 될까? 그러면 최종적으로 성공한 도익화의 타임스탬프만 전송하면 모든것을 최신 상태로 유지할 수 있다. 서버는 이 타임스탬프를 모든 데이터 항목의 최종 수정시간과 비교하여 응답방법을 결정한다.
- 프로세스는 서버중심적이며, 타임스탬프 생성도 서버에 의존한다.(타임스탬프는 실제 시간일 필요는 없으며, 실제로 그렇게 해서도 안된다.)

#### 서버는 동기화된 최신항목의 타임스탬프를 저장하고, 클라이언트는 가장 최근에 성공한 타임스탬프를 저장한다. 따라서 클라이언트보다 더 최신의 타임스탬프를 갖는 항목이 서버에 없다면 이 타임스탬프 이후에 서버 데이터 저장소에는 변경이 없다. 하지만 몇 가지 변경이 있다면 클라이언트의 타임스탬프와 서버 항목의 타임스탬프를 비교하여 어떤 항목이 더 최신인지 알 수 있다.


### 서버에서 클라이언트로 동기화 : 
- 타임스탬프와 식별자(identity)를 서버의 모든 데이터 항목에 추가한다.
- 클라이언트 타임스탬프를 서버의 모든 데이터 항목과 비교한다.
(만일 서버의 모든 항목에 정렬된 인덱스가 있다면 실제로 클라이언트 타임스탬프와 서버의 모든 항목을 비교할 필요가 없다. 그러므로 정렬된 인텍스가 있는 데이터베이스를 사용하면 성능을 유지할수 있다.
)

클라이언트측에서 예상되는 작업:
- 서버에 전송한 최종 타임스탬프와 동기화한다.
- 서버가 응답한 새 데이터로 로컬 저장소를 업데이트한다.
- 에러없이 완료되면 최종 동기화의 로컬 타임스탬프를 업데이트한다.


#### 인터페이스 업데이트
- 현재 양측에 업데이트 된 데이터 저장소가 생겼다. 서버를 시작으로 이제 데이터 저장소는 데이터 항목의 배열을 포함한다. 따라서 ServerDataItem 인터페이스를 정의하고 ServerDataStore도 업데이트한다.
`{[id:string] : ServerDataItem} ` 타입은 key로 string 타입의 id를 갖는 객체를 의미하며, ServerDataItem 타입의 값을 갖는다. 따라서 items['the-id]로 ServerdataItem 타입의 항목에 액세스 할수있다.

- 그리고 클라이언트의 경우 이제는 다른 데이터 항목과 다른 저장소를 갖게 되엇다.
응답에는 모든 데이터 항목의 하위집합(subset)만 포함되므로, ID들과 데이터를 저장하기 위한 인덱스로 ID 가 있는 맵이 필요하다.
```
export interface ClientDataItem {
  id: string;
  value: string;
}

export interface ClientDataStore {
  timestamp: number;
  items: {
    [id: string]: ClientDataItem;
  };
}
```


- 앞서 클라이언트와 서버는 동일한 DataSyncingInfo를 공유했지만, 변경할 예정이다. 먼저 서버에서 클라이언트로의 동기화를 다룰 예정이므로 우선은 동기화 요청의 타임스탬프만 고려하겠다.
``` 
export interface SyncingRequest {
  timestamp: number;
}
```

- 서버의 응답에는 요청 타임스탬프와 비교하여 변경된 데이터항목으로 업데이트된 타임스탬프가 있어야한다.
```
export interface SyncingResponse {
  timestamp: number;
  changes: {
    [id: string]: string;
  };
}
```

#### 서버측 업데이트
- 데이터 구조를 잘 정의하면 원하는 목표를 쉽게 달성할 수 있다. 먼저 SyncingRequest를 받아 SyncingRequest를 반환하는 synchronize메서드를 만든다. 이때 업데이트된 타임스탬프도 필요하다.
```
  synchronize(request: SyncingRequest): SyncingResponse {
    let lastTimestamp = request.timestamp;
    let now = Date.now();
    let serverChanges: ServerChangeMap = Object.create(null);

    return {
      timestamp: now,
      changes: serverChanges,
    };
  }
```
- tip : serverChange 객체의 경우 {}(객체 리터럴)이 가장 먼저 떠오를 수 있다. 하지만 , serverChanges 객체에서는 \__proto__ 를 키로 사용할 수 없기 때문에 객체 리터럴이 완벽하게 안전하다고 할 수는 없다. 따라서 모든 문자열을 받는 Object.create(null)이 더 나은 선택이 될 수 있다.
- 이제 클라이언트보다 더 새로운 항목을 SyncingResponse에 추가한다.
```
let items = this.store.items;

    for (let id of Object.keys(items)) {
      let item = items[id];
      if (item.timestamp > lastTimestamp) {
        serverChanges[id] = item.value;
      }
    }
```

#### 클라이언트 측 업데이트
- ClientDataStore에 있는 items 타입을 맵으로 변경했으므로 초기 값을 수정해야한다.
```
store: ClientDataStore = {
    timestamp: 0,
    items: Object.create(null),
  };
```

- 이제 synchronize 메서드를 업데이트한다. 먼저 클라이언트는 타임스탬프가 포함된 요청을 전송하고 서버로부터 응답을 받는다.
```
synchronize(): void {
    let store = this.store;
    let response = this.server.synchronize({
      timestamp: store.timestamp,
    });
```
- 그런 다음 더 최신인 데이터 항목을 저장소에 저장한다.
```
    let clientItems = store.items;
    let serverChanges = response.changes;

    for (let id of Object.keys(serverChanges)) {
      clientItems[id] = {
        id,
        value: serverChanges[id],
      };
    }

  }
```

- 마지막으로 최종적으로 성공한 동기화의 타임스탬프를 업데이트한다.
```
    store.timestamp = response.timestamp;

```
- (!) 동기화 타임스탬프 업데이트는 전체 동기화 프로세스에서 가장 마지막에 수행해야한다. 동기화 타임스탬프가 데이터 항목보다 먼저 저장되지 않도록 하라. 이렇게 하지 않으면 향후 동기화중에 에러나 중단 발생시 손상된 오프라인 사본이 생길 수 있다.
- (!) 계획대로 동작하게 하려면 동일한 변경정보가 있는 작업을 여러번 적용하더라도 동일한 결과가 나오는지 확인해야한다.

### 클라이언트에서 서버로의 동기화
- 서버 중심적 동기화 프로세스의 경우 대부분 변경은 클라이언트를 통해 이뤄진다. 따라서 변경을 서버에 전송하기 전에 구성하는 방법을 알아야한다.
- 하나의 단일 클라이언트는 자체 데이터 사본만 처리한다. 이는 서버에서 클라이언트로 데이터를 동기화하는 프로세스와 비교하면 어떤 차이가 있을까? 우선 타임스탬프가 필요한 이유는 특정 클라이언트와 비교하여 어떤 항목이 새로운 것인지 알아야 하기 때문이다.
- 변경이 발생하면 비교를 위한 특정 **타임스탬프를 요청하지 않고** 서버와 동기화해야한다.
- 하지만 두개 이상의 클라이언트에서 변경이 발생해 동기화가 필요한 경우가 있을 수 있다. 이는 시간상 나중에 발생한 변경이 실제로 더 먼저 동기화될 수 있음을 의미하며 이러한 충돌을 해결해야한다.
- 이를 해결하기 위해선 **최종 수정시간을 서버의 모든 데이터 항목과 클라이언트의 변경된 항목에 다시 추가**해야한다.
- 클라이언트와의 동기화 대상을 찾기위해 서버에 저장하는 타임스탬프는 물리적인 시점의 실제 시간일 필요는 없다. 예컨대 타임스탬프는 모든 클라이언트와 서버간 발생한 동기화 횟수가 될 수도 있다.


#### 클라이언트 측 업데이트
- 이 작업을 효과적으로 처리하기 위해 키로는 변경된 데이터 항목의 ID를 , 값으로는 최종수정 시간을 갖는 별도의 맵을 ClientDataStore에 생성한다.
```
export interface ClientDataStore{
    timestamp : number;
    items : {
        [id:string] : ClientDataItem;
        }
    changed : {
        [id:string] : number;
        }
}
```
